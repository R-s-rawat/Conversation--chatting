// communication application

// cna (create next app) template for basic structure of our next app (Full stack -> frontend and backend in one place(full potential))

// 1st thing 1st, modelling,; create model directory(/model) within source directory (/src) for storing what data is being stored (so 1st database structure thing is a good start whenever a application development starts)

// so data modelling for database (backend),, WORKFLOW (âœ…interface â†’ âœ…schema â†’ âœ…model)

// we are just storing users and messages sent to them... (so database would be not of higher complexity), 

// create a file named (User.ts) within models directory (/models), (tip: can also use naming like user.model.ts)

// We will now (install mongoose), which is an ORM/ODM, (which makes mongoDB queries writing easier) working as a intermediate, Mongoose is an ODM (Object Data Modeling), not a strict ORM (which is SQL).

.. // we will import {Document} from "mongoose" in (User.ts) for type safety purposes.. (Import Document for type safety)
__________________________________________________________________
111111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
ğŸ·ï¸ Section: IMessage Interface + MessageSchema
ğŸ’¡ Context / Why it matters

We need a Message model to store messages sent to users. TypeScript interfaces provide compile-time type safety, while Mongoose schemas define DB structure.

ğŸ› ï¸ Implementation (Steps / Workflow)

Create a TypeScript interface IMessage for the message object.

Define a Mongoose schema MessageSchema using the interface for type safety.

Use the schema to create a Mongoose model when needed.

ğŸ’» Example Code
// TypeScript interface
export interface IMessage extends Document {
  content: string;
  createdAt: Date;
}

// Mongoose schema
const MessageSchema: Schema<IMessage> = new Schema({
  content: { type: String, required: true },
  createdAt: { type: Date, required: true, default: Date.now }
});

ğŸ“Œ Key Points / Takeaways

âœ… Interfaces in PascalCase (IMessage)

âœ… Schema keys in camelCase (content, createdAt)

âš ï¸ TS will catch type mismatches at build time
__________________________________________________________________
11111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
ğŸ“Œ if any wrong type is defined, then caught type error..

// using the custom interfaces for type safety, first writing the data type(eg. Schema), then custom interface in our case, in diamond brackets
const MessageSchema: Schema<IMessage> = new Schema({
  content:{
        type: String,
        required: true
    },
    createdAt:{
        type: Date,
        required: true,
        default: Date.now
    }
})

// After message, we will do same for the user -> typescript INTERFACE and mongoose schema

ğŸ¥Š So, typescript enables many bugs to be caught at build time, by the type checker / compiler (enforce the correctness of data types)

// keep, create interface (ts schemas) then mongoose schemas.. now after IMessage->IUser i.e (IUser interface + UserSchema)

__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________
ğŸ·ï¸ Section: IUser Interface + UserSchema
ğŸ’¡ Context / Why it matters

We need a User model that stores application users. Each user may have multiple messages. Interfaces ensure type safety, and schemas enforce DB structure.

ğŸ› ï¸ Implementation (Steps / Workflow)

Create IUser interface with user fields.

Embed IMessage[] for messages.

Define UserSchema using the interface.

ğŸ’» Example Code
export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  verifyCode: string;
  verifyCodeExpiry: Date;
  isAcceptingMessage: boolean;
  messages: IMessage[];
}

const UserSchema: Schema<IUser> = new Schema({
  username: { type: String, required: true },
  email: { type: String, required: true, match: /.+\@.+\..+/ },
  password: { type: String, required: true },
  verifyCode: { type: String, required: true },
  verifyCodeExpiry: { type: Date, required: true },
  isAcceptingMessage: { type: Boolean, default: true },
  messages: [MessageSchema]
});

ğŸ“Œ Key Points / Takeaways

âœ… PascalCase interface (IUser)

âœ… Schema keys camelCase

âœ… Email regex validation in schema

âš ï¸ Keep interface properties in sync with schema
__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________

// using match operator for (email syntax validation), has to use the Regex Expression

___________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
__________________________________________________________________
ğŸ·ï¸ Section: Next.js vs Express Backend
ğŸ’¡ Context / Why it matters

Next.js API routes are serverless/stateless, unlike Express which is persistent. Understanding this affects state management and DB calls.

ğŸ› ï¸ Implementation (Steps / Workflow)

Express: runs continuously on a server.

Next.js: runs per request, resets after each call.

Use DB or external storage for persistence.

ğŸ’» Example Code
// Express
import express from "express";
const app = express();
app.listen(4000);

// Next.js API route
export default function handler(req, res) {
  res.status(200).json({ message: "Hello from Next.js" });
}

ğŸ“Œ Key Points / Takeaways

âš ï¸ Next.js API routes are stateless

âœ… Avoid relying on in-memory variables

âœ… Use DB / Redis for persistent state
__________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
____________________________________________________________________

// we will write two conditions for writing the models after the schema creation, i.e 1st get existing and 2nd if not exist then add.(along with typescript)

__________________________________________________________________
44444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________
ğŸ·ï¸ Section: Models & Naming Conventions
ğŸ’¡ Context / Why it matters

Define User model safely and maintain naming conventions, while avoiding duplicate compilation issues during hot reloads.

ğŸ› ï¸ Implementation (Steps / Workflow)

Models in singular (User).

Interfaces in PascalCase (IUser).

Schema keys in camelCase.

Use mongoose.models.User to avoid redefinition errors.

ğŸ’» Example Code
// Explicit collection name
const UserModel = mongoose.model("User", UserSchema, "User");

// Strong typing
const UserModel: Model<IUser> =
  mongoose.model<IUser>("User", UserSchema, "User");

// Hot-reload safe
const UserModel =
  (mongoose.models.User as mongoose.Model<IUser>) ||
  mongoose.model<IUser>("User", UserSchema, "User");

ğŸ“Œ Key Points / Takeaways

âœ… Hot-reload safety

âœ… Type-safe model (IUser)

âš ï¸ Without type param, .find(), .create() return generic Model
__________________________________________________________________
444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________

__________________________________________________________________
55555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________
ğŸ·ï¸ Section: Input Validation Schemas (Zod)
ğŸ’¡ Context / Why it matters

Validate user input (signup, signin, messages) before hitting the database. Mongoose alone doesnâ€™t validate runtime data fully.

ğŸ› ï¸ Implementation (Steps / Workflow)

Install Zod.

Define schemas for each route.

Validate requests using Zod before saving to DB.

ğŸ’» Example Code
import { z } from "zod";

export const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(6)
});

export const signInSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

export const messageSchema = z.object({
  content: z.string().min(1).max(500)
});

ğŸ“Œ Key Points / Takeaways

âœ… Validate input before DB writes

âœ… Runtime safety + TypeScript safety

âš ï¸ Mongoose schema alone â‰  full input validation
__________________________________________________________________
555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________

// create schemas, (for validation purposes only)
signUpSchema.ts 
verifySchema.ts
signInSchema.ts
acceptMessageSchema.ts  
messageSchema.ts

// INSTALL ZODğŸ”°ğŸš€ğŸ’šâœ¨â­

