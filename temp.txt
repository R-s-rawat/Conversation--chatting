// communication application

// cna (create next app) template for basic structure of our next app (Full stack -> frontend and backend in one place(full potential))

// 1st thing 1st, modelling,; create model directory(/model) within source directory (/src) for storing what data is being stored (so 1st database structure thing is a good start whenever a application development starts)

// so data modelling for database (backend),, WORKFLOW (âœ…interface â†’ âœ…schema â†’ âœ…model)

// we are just storing users and messages sent to them... (so database would be not of higher complexity), 

// create a file named (User.ts) within models directory (/models), (tip: can also use naming like user.model.ts)

// We will now (install mongoose), which is an ORM/ODM, (which makes mongoDB queries writing easier) working as a intermediate, Mongoose is an ODM (Object Data Modeling), not a strict ORM (which is SQL).

.. // we will import {Document} from "mongoose" in (User.ts) for type safety purposes.. (Import Document for type safety)
__________________________________________________________________
111111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
ğŸ·ï¸ Section: IMessage Interface + MessageSchema
ğŸ’¡ Context / Why it matters

We need a Message model to store messages sent to users. TypeScript interfaces provide compile-time type safety, while Mongoose schemas define DB structure.

ğŸ› ï¸ Implementation (Steps / Workflow)

Create a TypeScript interface IMessage for the message object.
Define a Mongoose schema MessageSchema using the interface for type safety.
Use the schema to create a Mongoose model when needed.

ğŸ’» Example Code
// TypeScript interface
export interface IMessage extends Document {
  content: string;
  createdAt: Date;
}

// Mongoose schema
const MessageSchema: Schema<IMessage> = new Schema({
  content: { type: String, required: true },
  createdAt: { type: Date, required: true, default: Date.now }
});

ğŸ“Œ Key Points / Takeaways

âœ… Interfaces in PascalCase (IMessage)
âœ… Schema keys in camelCase (content, createdAt)
âš ï¸ TS will catch type mismatches at build time
__________________________________________________________________
11111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
ğŸ“Œ if any wrong type is defined, then caught type error..

// using the custom interfaces for type safety, first writing the data type(eg. Schema), then custom interface in our case, in diamond brackets
const MessageSchema: Schema<IMessage> = new Schema({
  content:{
        type: String,
        required: true
    },
    createdAt:{
        type: Date,
        required: true,
        default: Date.now
    }
})

// After message, we will do same for the user -> typescript INTERFACE and mongoose schema

ğŸ¥Š So, typescript enables many bugs to be caught at build time, by the type checker / compiler (enforce the correctness of data types)

// keep, create interface (ts schemas) then mongoose schemas.. now after IMessage->IUser i.e (IUser interface + UserSchema)

__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________
ğŸ·ï¸ Section: IUser Interface + UserSchema
ğŸ’¡ Context / Why it matters

We need a User model that stores application users. Each user may have multiple messages. Interfaces ensure type safety, and schemas enforce DB structure.

ğŸ› ï¸ Implementation (Steps / Workflow)

Create IUser interface with user fields.
Embed IMessage[] for messages.
Define UserSchema using the interface.

ğŸ’» Example Code
export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  verifyCode: string;
  verifyCodeExpiry: Date;
  isAcceptingMessage: boolean;
  messages: IMessage[];
}

const UserSchema: Schema<IUser> = new Schema({
  username: { type: String, required: true },
  email: { type: String, required: true, match: /.+\@.+\..+/ },
  password: { type: String, required: true },
  verifyCode: { type: String, required: true },
  verifyCodeExpiry: { type: Date, required: true },
  isAcceptingMessage: { type: Boolean, default: true },
  messages: [MessageSchema]
});

ğŸ“Œ Key Points / Takeaways

âœ… PascalCase interface (IUser)
âœ… Schema keys camelCase
âœ… Email regex validation in schema
âš ï¸ Keep interface properties in sync with schema
__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________

// using match operator for (email syntax validation), has to use the Regex Expression

___________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
__________________________________________________________________
ğŸ·ï¸ Section: Next.js vs Express Backend
ğŸ’¡ Context / Why it matters

Next.js API routes are serverless/stateless, unlike Express which is persistent. Understanding this affects state management and DB calls.

ğŸ› ï¸ Implementation (Steps / Workflow)

Express: runs continuously on a server.
Next.js: runs per request, resets after each call.
Use DB or external storage for persistence.

ğŸ’» Example Code
// Express
import express from "express";
const app = express();
app.listen(4000);

// Next.js API route
export default function handler(req, res) {
  res.status(200).json({ message: "Hello from Next.js" });
}

ğŸ“Œ Key Points / Takeaways

âš ï¸ Next.js API routes are stateless
âœ… Avoid relying on in-memory variables
âœ… Use DB / Redis for persistent state
__________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
____________________________________________________________________

// we will write two conditions for writing the models after the schema creation, i.e 1st get existing and 2nd if not exist then add.(along with typescript)

__________________________________________________________________
44444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________
ğŸ·ï¸ Section: Models & Naming Conventions
ğŸ’¡ Context / Why it matters

Define User model safely and maintain naming conventions, while avoiding duplicate compilation issues during hot reloads.

ğŸ› ï¸ Implementation (Steps / Workflow)

Models in singular (User).
Interfaces in PascalCase (IUser).
Schema keys in camelCase.
Use mongoose.models.User to avoid redefinition errors.

ğŸ’» Example Code
// Explicit collection name
const UserModel = mongoose.model("User", UserSchema, "User");

// Strong typing
const UserModel: Model<IUser> =
  mongoose.model<IUser>("User", UserSchema, "User");

// Hot-reload safe
const UserModel =
  (mongoose.models.User as mongoose.Model<IUser>) ||
  mongoose.model<IUser>("User", UserSchema, "User");

ğŸ“Œ Key Points / Takeaways

âœ… Hot-reload safety
âœ… Type-safe model (IUser)
âš ï¸ Without type param, .find(), .create() return generic Model
__________________________________________________________________
444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________

__________________________________________________________________
55555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________
ğŸ·ï¸ Section: Input Validation Schemas (Zod)
ğŸ’¡ Context / Why it matters

Validate user input (signup, signin, messages) before hitting the database. Mongoose alone doesnâ€™t validate runtime data fully.

ğŸ› ï¸ Implementation (Steps / Workflow)

Install Zod.
Define schemas for each route.
Validate requests using Zod before saving to DB.

ğŸ’» Example Code
import { z } from "zod";

export const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(6)
});

export const signInSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

export const messageSchema = z.object({
  content: z.string().min(1).max(500)
});

ğŸ“Œ Key Points / Takeaways

âœ… Validate input before DB writes
âœ… Runtime safety + TypeScript safety
âš ï¸ Mongoose schema alone â‰  full input validation
__________________________________________________________________
555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________

// create schemas, (for validation purposes only)
signUpSchema.ts 
verifyOtpSchema.ts
signInSchema.ts
acceptMessageSchema.ts  
messageSchema.ts

// INSTALL ZODğŸ”°ğŸš€ğŸ’šâœ¨â­ - object schema and validation (chaining)

define validation schemas as per the flow, like signup, verifyOtp, signIn(check identifier(developers terminology for emails or anything unique)), acceptMessage, message etc(if any schema extra for more depth)...

// as nextJS is edge time framework (db connects on requests), so we will first check if db connection exists due to just previous invocation to not cause any choke while invoking requests, so prevent db throttling by checking if -> connection.isConnected then -> return;

// create a dbConnect.ts within new directory "lib" within existing "src"

// the void we are using in our db connection contextually means by the ts(typeScript) that i technically not know what kind of data return

// now have logic for db connection, and add .env to the root of our project for our environment variables (we are not going to git commit (env's) for backups and versioning)

// we need to know all flow, like mongoose one and the nextAuth(by nextJS), as signUps requires a lot of info from users

// we will use Resend Email package, the latest development and not go for most used previous ones like nodemailer

// we will implement a algorithm for our flow of application that is designed keeping in mind few practical scenarios:

code should efficiently handle both scenarios of (1. registering a new user) & (2. updating an existing but unverified) user account with new passoword and verification code

IF existingUserByEmail EXISTS THEN
   IF existingUserByEmail.isVerified THEN
      success: false
   ELSE 
      // save the updated user
   END IF
ELSE 
   // Create a new user with provided details
   // Save the new user
END IF

Example: âœğŸ’› // for eg. if using database library like Prisma or TypeORM

const existingUser = await User.findOne({ where: { email } }); // Find user by email

if (existingUser) âœ¨
    { // User exists
         if (existingUser.isVerified) {
           return { success: false, message: 'User already verified' }; // User already verified
         } 
         else {
           // Update user details (assuming otherUserDetails contains the updated data)
           await User.update({ where: { email }, data: { ...otherUserDetails, isVerified: true } }); // Update user fields and set isVerified to true
           return { success: true, message: 'User details updated' };
         }
    } 
else âœ¨
    { // User does not exist
      // Create new user (assuming otherUserDetails contains necessary data)
      const newUser = await User.create({ email, isVerified: false, ...otherUserDetails });
      return { success: true, message: 'User created', userId: newUser.id }; // Return the new user's ID if needed
    }
  
// Now we will have our api key for email provider (Resend email)

// new folder outside "src" i.e "emails" having VerificationEmail.tsx(ts component) as we can later create different emails and can be put outside "src"

// npm i react-email 

// KEEP STANDARDIZING THINGS, by better directories strucuture and code practises to keep production level Understanding good for later better versioning and feature branches..

// create a new directory for custom types "types" within "src" (for type safety using ts)

// most of time interfaces are used when we define types.. (so we will opt for it, better one)

// use "?" optional when defining types whenever necessary..

// BEST TO HAVE DEFENSIVE CODE for all scenarios of what a api should tackle,

// TypeScript (and JS) allows you to omit semicolons in many cases, (but better for readability)

// So, as we used a folder named "types" with type definitions eg. ApiResponse.ts
export interface ApiResponse{
    success: boolean;
    message: string,
    ...
}

// so, when we will use that interface imported from types directory, in some other place like function eg. sendVerificationEmail along with interface for type safety checks, we have to ensure the usage of mandatory fields defined in the type definiton.
export async function sendVerificationEmail(
    email: string,
    username: string,
    verifyCode: string, 
): Promise<ApiResponse>{
    try {
         return {success:true, message:"Passed to send verification email"}
    }catch{
       return {success:false, message:"Failed to send verification email"}
    }
}
__________________________________________________________________
6666666666666666666666666666666666666666666666666666666666666666666
__________________________________________________________________
ğŸ·ï¸ Section: Shared Types (ApiResponse) and Function Return Types
ğŸ’¡ Context / Why it matters

To keep the project clean and consistent, we define shared types in a dedicated /types folder (e.g., ApiResponse.ts).
This allows:

âœ… Reuse across multiple files
âœ… Enforced type safety for function responses
âœ… Consistency of API responses

ğŸ› ï¸ Implementation (Steps / Workflow)

Create /types/ApiResponse.ts to define a common response structure.
Import and use this interface in functions that return API results.
TypeScript enforces that returned objects must include all required fields.

ğŸ’» Example Code
// /types/ApiResponse.ts
export interface ApiResponse {
  success: boolean;
  message: string;
  // Add optional fields if needed, e.g. data?: T
}

// Example usage in a utility function
export async function sendVerificationEmail(
  email: string,
  username: string,
  verifyCode: string
): Promise<ApiResponse> {
  try {
    return { success: true, message: "Passed to send verification email" };
  } catch {
    return { success: false, message: "Failed to send verification email" };
  }
}

ğŸ“Œ Key Points / Takeaways

âœ… Shared types live in /types folder
âœ… Always use PascalCase for interfaces (ApiResponse)
âœ… Function explicitly returns Promise<ApiResponse>
âš ï¸ TS enforces presence of success and message
__________________________________________________________________
6666666666666666666666666666666666666666666666666666666666666666666
__________________________________________________________________

// Dependencies â†’ pinned(exact version) = predictable production.
//DevDependencies â†’ flexible (^) = smoother developer experience.
NOTE: for better reproducibility, using exact version for devDependencies helps developers teams

// NOW, "api" folder inside "app" folder of "src" (nextJS serves api through this directory)

// within "api" directory the diectory name becomes routes, eg. sign-up directory

// and "route.ts" naming convention is also compulsory, imposed by nextJS framework..

// db connection is common in every route, as nextJS runs on edge time (when invoked)

// we have to write route functions as per request method, as per flow i.e app->api->sign-up->..

// do await and trigger db connection (post request for our signup route)

// if we just pass Resend api key not the mongodb uri, then errors is confirm, eg. Connection was forcibly closed by a peer.

// so, after mongodb uri, and resend too.. the resend otp is having a issue, causing our api route to throw error ie.
{
    "success": false,
    "message": "Failed to send verification email"
}

__________________________________________________________________
777777777777777777777777777777777777777777777777777777777777777777
__________________________________________________________________
ğŸ·ï¸ Section: Api (Developers terminology(DX) like payload, request/response body)
ğŸ’¡ Context / Why it matters

When documenting or discussing APIs, using the right term helps avoid confusion. Developers often mix payload and body, but they arenâ€™t always interchangeable in professional contexts.

ğŸ› ï¸ Clarification

>Request Payload (Preferred Term)
Data sent by the client to the server, usually in the body of the HTTP request.
Example: JSON payload for creating a new user.

>Request Body (Common Alternative)
Refers to the same content, but is less precise. It emphasizes the location (inside the HTTP request) rather than the role (data being transmitted).

>Response Payload
Data returned by the server to the client, usually in the response body.
Example: Newly created userâ€™s details, product list, or error messages.

>Response Body (Alternative Name)
Another valid way to refer to the response payload, focusing again on where the data sits (inside the HTTP response message). [actually more precise than â€œrequest bodyâ€]

ğŸ’» Example
POST /api/users HTTP/1.1
Host: example.com
Content-Type: application/json
{
  "username": "rohan98",
  "email": "test@example.com"
}
The JSON object here is the request payload (or request body).

The server might reply with:
{
  "success": true,
  "id": "12345"
}
This JSON is the response payload (or response body).

ğŸ“Œ Key Points / Takeaway

âœ… â€œPayloadâ€ = the actual transmitted data.
âœ… â€œBodyâ€ = the part of the HTTP message that holds the payload.
âš ï¸ Best practice: say request payload and response payload in docs for clarity.
âœ… Alternative term for response payload â†’ response body.
__________________________________________________________________
777777777777777777777777777777777777777777777777777777777777777777
__________________________________________________________________

// code should be collaborate in feature branches (for each feature) as app is composed of features..

__________________________________________________________________
888888888888888888888888888888888888888888888888888888888888888888
__________________________________________________________________
ğŸ”’ Open Source vs. Proprietary (with Cases)

ğŸ’¡ Context
Firebase is closed-source (proprietary, owned by Google). Question: can it be forked?

ğŸ“Œ Clarification
âŒ Forking Firebase itself isnâ€™t possible â†’ no access to its source code.
âœ… You can build/look for open-source alternatives (Supabase, Appwrite, Nhost) that re-implement Firebase-like functionality.

ğŸ” Difference: Open Source vs. Proprietary
Open Source â†’ source code available, modifiable, forkable, auditable, self deploy on your own server.
Proprietary â†’ vendor-owned, closed, only consumable via license/SDK.

ğŸ“Š Examples
Firebase â†’ proprietary.
Supabase â†’ open-source alternative.

ğŸ“ Takeaway
Forking = possible only with open-source.
Proprietary = vendor lock-in, no control.
Open-source = freedom, transparency, community-driven innovation.
__________________________________________________________________
888888888888888888888888888888888888888888888888888888888888888888
__________________________________________________________________
