// communication application

// cna (create next app) template for basic structure of our next app (Full stack -> frontend and backend in one place(full potential))

// 1st thing 1st, modelling,; create model directory(/model) within source directory (/src) for storing what data is being stored (so 1st database structure thing is a good start whenever a application development starts)

// so data modelling for database (backend),, WORKFLOW (‚úÖinterface ‚Üí ‚úÖschema ‚Üí ‚úÖmodel)

// we are just storing users and messages sent to them... (so database would be not of higher complexity), 

// create a file named (User.ts) within models directory (/models), (tip: can also use naming like user.model.ts)

// We will now (install mongoose), which is an ORM/ODM, (which makes mongoDB queries writing easier) working as a intermediate, Mongoose is an ODM (Object Data Modeling), not a strict ORM (which is SQL).

.. // we will import {Document} from "mongoose" in (User.ts) for type safety purposes.. (Import Document for type safety)
__________________________________________________________________
111111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
üè∑Ô∏è Section: IMessage Interface + MessageSchema
üí° Context / Why it matters

We need a Message model to store messages sent to users. TypeScript interfaces provide compile-time type safety, while Mongoose schemas define DB structure.

üõ†Ô∏è Implementation (Steps / Workflow)

Create a TypeScript interface IMessage for the message object.
Define a Mongoose schema MessageSchema using the interface for type safety.
Use the schema to create a Mongoose model when needed.

üíª Example Code
// TypeScript interface
export interface IMessage extends Document {
  content: string;
  createdAt: Date;
}

// Mongoose schema
const MessageSchema: Schema<IMessage> = new Schema({
  content: { type: String, required: true },
  createdAt: { type: Date, required: true, default: Date.now }
});

üìå Key Points / Takeaways

‚úÖ Interfaces in PascalCase (IMessage)
‚úÖ Schema keys in camelCase (content, createdAt)
‚ö†Ô∏è TS will catch type mismatches at build time
__________________________________________________________________
11111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
üìå if any wrong type is defined, then caught type error..

// using the custom interfaces for type safety, first writing the data type(eg. Schema), then custom interface in our case, in diamond brackets
const MessageSchema: Schema<IMessage> = new Schema({
  content:{
        type: String,
        required: true
    },
    createdAt:{
        type: Date,
        required: true,
        default: Date.now
    }
})

// After message, we will do same for the user -> typescript INTERFACE and mongoose schema

ü•ä So, typescript enables many bugs to be caught at build time, by the type checker / compiler (enforce the correctness of data types)

// keep, create interface (ts schemas) then mongoose schemas.. now after IMessage->IUser i.e (IUser interface + UserSchema)

__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________
üè∑Ô∏è Section: IUser Interface + UserSchema
üí° Context / Why it matters

We need a User model that stores application users. Each user may have multiple messages. Interfaces ensure type safety, and schemas enforce DB structure.

üõ†Ô∏è Implementation (Steps / Workflow)

Create IUser interface with user fields.
Embed IMessage[] for messages.
Define UserSchema using the interface.

üíª Example Code
export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  verifyCode: string;
  verifyCodeExpiry: Date;
  isAcceptingMessage: boolean;
  messages: IMessage[];
}

const UserSchema: Schema<IUser> = new Schema({
  username: { type: String, required: true },
  email: { type: String, required: true, match: /.+\@.+\..+/ },
  password: { type: String, required: true },
  verifyCode: { type: String, required: true },
  verifyCodeExpiry: { type: Date, required: true },
  isAcceptingMessage: { type: Boolean, default: true },
  messages: [MessageSchema]
});

üìå Key Points / Takeaways

‚úÖ PascalCase interface (IUser)
‚úÖ Schema keys camelCase
‚úÖ Email regex validation in schema
‚ö†Ô∏è Keep interface properties in sync with schema
__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________

// using match operator for (email syntax validation), has to use the Regex Expression

___________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
__________________________________________________________________
üè∑Ô∏è Section: Next.js vs Express Backend
üí° Context / Why it matters

Next.js API routes are serverless/stateless, unlike Express which is persistent. Understanding this affects state management and DB calls.

üõ†Ô∏è Implementation (Steps / Workflow)

Express: runs continuously on a server.
Next.js: runs per request, resets after each call.
Use DB or external storage for persistence.

üíª Example Code
// Express
import express from "express";
const app = express();
app.listen(4000);

// Next.js API route
export default function handler(req, res) {
  res.status(200).json({ message: "Hello from Next.js" });
}

üìå Key Points / Takeaways

‚ö†Ô∏è Next.js API routes are stateless
‚úÖ Avoid relying on in-memory variables
‚úÖ Use DB / Redis for persistent state
__________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
____________________________________________________________________

// we will write two conditions for writing the models after the schema creation, i.e 1st get existing and 2nd if not exist then add.(along with typescript)

__________________________________________________________________
44444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________
üè∑Ô∏è Section: Models & Naming Conventions
üí° Context / Why it matters

Define User model safely and maintain naming conventions, while avoiding duplicate compilation issues during hot reloads.

üõ†Ô∏è Implementation (Steps / Workflow)

Models in singular (User).
Interfaces in PascalCase (IUser).
Schema keys in camelCase.
Use mongoose.models.User to avoid redefinition errors.

üíª Example Code
// Explicit collection name
const UserModel = mongoose.model("User", UserSchema, "User");

// Strong typing
const UserModel: Model<IUser> =
  mongoose.model<IUser>("User", UserSchema, "User");

// Hot-reload safe
const UserModel =
  (mongoose.models.User as mongoose.Model<IUser>) ||
  mongoose.model<IUser>("User", UserSchema, "User");

üìå Key Points / Takeaways

‚úÖ Hot-reload safety
‚úÖ Type-safe model (IUser)
‚ö†Ô∏è Without type param, .find(), .create() return generic Model
__________________________________________________________________
444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________

__________________________________________________________________
55555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________
üè∑Ô∏è Section: Input Validation Schemas (Zod)
üí° Context / Why it matters

Validate user input (signup, signin, messages) before hitting the database. Mongoose alone doesn‚Äôt validate runtime data fully.

üõ†Ô∏è Implementation (Steps / Workflow)

Install Zod.
Define schemas for each route.
Validate requests using Zod before saving to DB.

üíª Example Code
import { z } from "zod";

export const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(6)
});

export const signInSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

export const messageSchema = z.object({
  content: z.string().min(1).max(500)
});

üìå Key Points / Takeaways

‚úÖ Validate input before DB writes
‚úÖ Runtime safety + TypeScript safety
‚ö†Ô∏è Mongoose schema alone ‚â† full input validation
__________________________________________________________________
555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________

// create schemas, (for validation purposes only)
signUpSchema.ts 
verifyOtpSchema.ts
signInSchema.ts
acceptMessageSchema.ts  
messageSchema.ts

// INSTALL ZODüî∞üöÄüíö‚ú®‚≠ê - object schema and validation (chaining)

define validation schemas as per the flow, like signup, verifyOtp, signIn(check identifier(developers terminology for emails or anything unique)), acceptMessage, message etc(if any schema extra for more depth)...

// as nextJS is edge time framework (db connects on requests), so we will first check if db connection exists due to just previous invocation to not cause any choke while invoking requests, so prevent db throttling by checking if -> connection.isConnected then -> return;

// create a dbConnect.ts within new directory "lib" within existing "src"

// the void we are using in our db connection contextually means by the ts(typeScript) that i technically not know what kind of data return

// now have logic for db connection, and add .env to the root of our project for our environment variables (we are not going to git commit (env's) for backups and versioning)

// we need to know all flow, like mongoose one and the nextAuth(by nextJS), as signUps requires a lot of info from users

// we will use Resend Email package, the latest development and not go for most used previous ones like nodemailer

// we will implement a algorithm for our flow of application that is designed keeping in mind few practical scenarios:

code should efficiently handle both scenarios of (1. registering a new user) & (2. updating an existing but unverified) user account with new passoword and verification code

IF existingUserByEmail EXISTS THEN
   IF existingUserByEmail.isVerified THEN
      success: false
   ELSE 
      // save the updated user
   END IF
ELSE 
   // Create a new user with provided details
   // Save the new user
END IF

Example: ‚úçüíõ // for eg. if using database library like Prisma or TypeORM

const existingUser = await User.findOne({ where: { email } }); // Find user by email

if (existingUser) ‚ú®
    { // User exists
         if (existingUser.isVerified) {
           return { success: false, message: 'User already verified' }; // User already verified
         } 
         else {
           // Update user details (assuming otherUserDetails contains the updated data)
           await User.update({ where: { email }, data: { ...otherUserDetails, isVerified: true } }); // Update user fields and set isVerified to true
           return { success: true, message: 'User details updated' };
         }
    } 
else ‚ú®
    { // User does not exist
      // Create new user (assuming otherUserDetails contains necessary data)
      const newUser = await User.create({ email, isVerified: false, ...otherUserDetails });
      return { success: true, message: 'User created', userId: newUser.id }; // Return the new user's ID if needed
    }
  
// Now we will have our api key for email provider (Resend email)

// new folder outside "src" i.e "emails" having VerificationEmail.tsx(ts component) as we can later create different emails and can be put outside "src"

// npm i react-email 

// KEEP STANDARDIZING THINGS, by better directories strucuture and code practises to keep production level Understanding good for later better versioning and feature branches..

// create a new directory for custom types "types" within "src" (for type safety using ts)

// most of time interfaces are used when we define types.. (so we will opt for it, better one)

// use "?" optional when defining types whenever necessary..

// BEST TO HAVE DEFENSIVE CODE for all scenarios of what a api should tackle,

// TypeScript (and JS) allows you to omit semicolons in many cases, (but better for readability)

// So, as we used a folder named "types" with type definitions eg. ApiResponse.ts
export interface ApiResponse{
    success: boolean;
    message: string,
    ...
}

// so, when we will use that interface imported from types directory, in some other place like function eg. sendVerificationEmail along with interface for type safety checks, we have to ensure the usage of mandatory fields defined in the type definiton.
export async function sendVerificationEmail(
    email: string,
    username: string,
    verifyCode: string, 
): Promise<ApiResponse>{
    try {
         return {success:true, message:"Passed to send verification email"}
    }catch{
       return {success:false, message:"Failed to send verification email"}
    }
}
__________________________________________________________________
6666666666666666666666666666666666666666666666666666666666666666666
__________________________________________________________________
üè∑Ô∏è Section: Shared Types (ApiResponse) and Function Return Types
üí° Context / Why it matters

To keep the project clean and consistent, we define shared types in a dedicated /types folder (e.g., ApiResponse.ts).
This allows:

‚úÖ Reuse across multiple files
‚úÖ Enforced type safety for function responses
‚úÖ Consistency of API responses

üõ†Ô∏è Implementation (Steps / Workflow)

Create /types/ApiResponse.ts to define a common response structure.
Import and use this interface in functions that return API results.
TypeScript enforces that returned objects must include all required fields.

üíª Example Code
// /types/ApiResponse.ts
export interface ApiResponse {
  success: boolean;
  message: string;
  // Add optional fields if needed, e.g. data?: T
}

// Example usage in a utility function
export async function sendVerificationEmail(
  email: string,
  username: string,
  verifyCode: string
): Promise<ApiResponse> {
  try {
    return { success: true, message: "Passed to send verification email" };
  } catch {
    return { success: false, message: "Failed to send verification email" };
  }
}

üìå Key Points / Takeaways

‚úÖ Shared types live in /types folder
‚úÖ Always use PascalCase for interfaces (ApiResponse)
‚úÖ Function explicitly returns Promise<ApiResponse>
‚ö†Ô∏è TS enforces presence of success and message
__________________________________________________________________
6666666666666666666666666666666666666666666666666666666666666666666
__________________________________________________________________

// Dependencies ‚Üí pinned(exact version) = predictable production.
//DevDependencies ‚Üí flexible (^) = smoother developer experience.
NOTE: for better reproducibility, using exact version for devDependencies helps developers teams

// NOW, "api" folder inside "app" folder of "src" (nextJS serves api through this directory)

// within "api" directory the diectory name becomes routes, eg. sign-up directory

// and "route.ts" naming convention is also compulsory, imposed by nextJS framework..

// db connection is common in every route, as nextJS runs on edge time (when invoked)

// we have to write route functions as per request method, as per flow i.e app->api->sign-up->..

// do await and trigger db connection (post request for our signup route)







