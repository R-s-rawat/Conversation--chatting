// communication application

// cna (create next app) template for basic structure of our next app (Full stack -> frontend and backend in one place(full potential))

// 1st thing 1st, modelling,; create model directory(/model) within source directory (/src) for storing what data is being stored (so 1st database structure thing is a good start whenever a application development starts)

// so data modelling for database (backend),, WORKFLOW (✅interface → ✅schema → ✅model)

// we are just storing users and messages sent to them... (so database would be not of higher complexity), 

// create a file named (User.ts) within models directory (/models), (tip: can also use naming like user.model.ts)

// We will now (install mongoose), which is an ORM/ODM, (which makes mongoDB queries writing easier) working as a intermediate, Mongoose is an ODM (Object Data Modeling), not a strict ORM (which is SQL).

.. // we will import {Document} from "mongoose" in (User.ts) for type safety purposes.. (Import Document for type safety)
__________________________________________________________________
111111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
🏷️ Section: IMessage Interface + MessageSchema
💡 Context / Why it matters

We need a Message model to store messages sent to users. TypeScript interfaces provide compile-time type safety, while Mongoose schemas define DB structure.

🛠️ Implementation (Steps / Workflow)

Create a TypeScript interface IMessage for the message object.

Define a Mongoose schema MessageSchema using the interface for type safety.

Use the schema to create a Mongoose model when needed.

💻 Example Code
// TypeScript interface
export interface IMessage extends Document {
  content: string;
  createdAt: Date;
}

// Mongoose schema
const MessageSchema: Schema<IMessage> = new Schema({
  content: { type: String, required: true },
  createdAt: { type: Date, required: true, default: Date.now }
});

📌 Key Points / Takeaways

✅ Interfaces in PascalCase (IMessage)

✅ Schema keys in camelCase (content, createdAt)

⚠️ TS will catch type mismatches at build time
__________________________________________________________________
11111111111111111111111111111111111111111111111111111111111111111
__________________________________________________________________
📌 if any wrong type is defined, then caught type error..

// using the custom interfaces for type safety, first writing the data type(eg. Schema), then custom interface in our case, in diamond brackets
const MessageSchema: Schema<IMessage> = new Schema({
  content:{
        type: String,
        required: true
    },
    createdAt:{
        type: Date,
        required: true,
        default: Date.now
    }
})

// After message, we will do same for the user -> typescript INTERFACE and mongoose schema

🥊 So, typescript enables many bugs to be caught at build time, by the type checker / compiler (enforce the correctness of data types)

// keep, create interface (ts schemas) then mongoose schemas.. now after IMessage->IUser i.e (IUser interface + UserSchema)

__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________
🏷️ Section: IUser Interface + UserSchema
💡 Context / Why it matters

We need a User model that stores application users. Each user may have multiple messages. Interfaces ensure type safety, and schemas enforce DB structure.

🛠️ Implementation (Steps / Workflow)

Create IUser interface with user fields.

Embed IMessage[] for messages.

Define UserSchema using the interface.

💻 Example Code
export interface IUser extends Document {
  username: string;
  email: string;
  password: string;
  verifyCode: string;
  verifyCodeExpiry: Date;
  isAcceptingMessage: boolean;
  messages: IMessage[];
}

const UserSchema: Schema<IUser> = new Schema({
  username: { type: String, required: true },
  email: { type: String, required: true, match: /.+\@.+\..+/ },
  password: { type: String, required: true },
  verifyCode: { type: String, required: true },
  verifyCodeExpiry: { type: Date, required: true },
  isAcceptingMessage: { type: Boolean, default: true },
  messages: [MessageSchema]
});

📌 Key Points / Takeaways

✅ PascalCase interface (IUser)

✅ Schema keys camelCase

✅ Email regex validation in schema

⚠️ Keep interface properties in sync with schema
__________________________________________________________________
2222222222222222222222222222222222222222222222222222222222222222222
__________________________________________________________________

// using match operator for (email syntax validation), has to use the Regex Expression

___________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
__________________________________________________________________
🏷️ Section: Next.js vs Express Backend
💡 Context / Why it matters

Next.js API routes are serverless/stateless, unlike Express which is persistent. Understanding this affects state management and DB calls.

🛠️ Implementation (Steps / Workflow)

Express: runs continuously on a server.

Next.js: runs per request, resets after each call.

Use DB or external storage for persistence.

💻 Example Code
// Express
import express from "express";
const app = express();
app.listen(4000);

// Next.js API route
export default function handler(req, res) {
  res.status(200).json({ message: "Hello from Next.js" });
}

📌 Key Points / Takeaways

⚠️ Next.js API routes are stateless

✅ Avoid relying on in-memory variables

✅ Use DB / Redis for persistent state
__________________________________________________________________
333333333333333333333333333333333333333333333333333333333333333333333
____________________________________________________________________

// we will write two conditions for writing the models after the schema creation, i.e 1st get existing and 2nd if not exist then add.(along with typescript)

__________________________________________________________________
44444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________
🏷️ Section: Models & Naming Conventions
💡 Context / Why it matters

Define User model safely and maintain naming conventions, while avoiding duplicate compilation issues during hot reloads.

🛠️ Implementation (Steps / Workflow)

Models in singular (User).

Interfaces in PascalCase (IUser).

Schema keys in camelCase.

Use mongoose.models.User to avoid redefinition errors.

💻 Example Code
// Explicit collection name
const UserModel = mongoose.model("User", UserSchema, "User");

// Strong typing
const UserModel: Model<IUser> =
  mongoose.model<IUser>("User", UserSchema, "User");

// Hot-reload safe
const UserModel =
  (mongoose.models.User as mongoose.Model<IUser>) ||
  mongoose.model<IUser>("User", UserSchema, "User");

📌 Key Points / Takeaways

✅ Hot-reload safety

✅ Type-safe model (IUser)

⚠️ Without type param, .find(), .create() return generic Model
__________________________________________________________________
444444444444444444444444444444444444444444444444444444444444444444
__________________________________________________________________

__________________________________________________________________
55555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________
🏷️ Section: Input Validation Schemas (Zod)
💡 Context / Why it matters

Validate user input (signup, signin, messages) before hitting the database. Mongoose alone doesn’t validate runtime data fully.

🛠️ Implementation (Steps / Workflow)

Install Zod.

Define schemas for each route.

Validate requests using Zod before saving to DB.

💻 Example Code
import { z } from "zod";

export const signUpSchema = z.object({
  username: z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/),
  email: z.string().email(),
  password: z.string().min(6)
});

export const signInSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

export const messageSchema = z.object({
  content: z.string().min(1).max(500)
});

📌 Key Points / Takeaways

✅ Validate input before DB writes

✅ Runtime safety + TypeScript safety

⚠️ Mongoose schema alone ≠ full input validation
__________________________________________________________________
555555555555555555555555555555555555555555555555555555555555555
__________________________________________________________________

// create schemas, (for validation purposes only)
signUpSchema.ts 
verifySchema.ts
signInSchema.ts
acceptMessageSchema.ts  
messageSchema.ts

// INSTALL ZOD🔰🚀💚✨⭐

